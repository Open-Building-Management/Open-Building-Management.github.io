<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <style>
  body { font: 10px Arial;}
  path {
    stroke-width: 1;
    fill: none;
  }
  .axis path,
  .axis line {
    fill: none;
    stroke: grey;
    stroke-width: 1;
    shape-rendering: crispEdges;
  }
  .axisRed text{
    fill: red;
  }
  </style>
  <!--<script src="https://d3js.org/d3.v4.min.js"></script>-->
  <script src="lib/d3.v6.min.js"></script>
  <script src="lib/jquery-3.5.1.min.js"></script>
  <link rel="stylesheet" href="lib/bootstrap-4.5.3-dist/css/bootstrap.min.css">
  <script src="lib/bootstrap-4.5.3-dist/js/bootstrap.bundle.min.js"></script>
</head>
<body>

<div class="container-fluid">
  <table class="table">
    <tr><td><img src=img/logo.svg class="img-fluid"></td></tr>
    <tr><td>
        Chez OBM, on cherche en permanence à produire des données signifiantes pour nos clients.
        Nos automates ne se contentent pas de recueillir les données brutes pour les envoyer vers un serveur de cloud de plus.
        Ils embarquent une API produisant de l'information compréhensible par les humains.
    </td></tr>
    <tr><td>
  </table>
  <div class="row-sm" id="filter">
    <table>
      <tr>
        <td>Confort intérieur de <input type=text id=Tmin value=19 size=2> à <input type=text id=Tmax value=21 size=2>°C</td>
      </tr>
    </table>
    <table>
      <tr>
        <td><select id=circuit></select></td>
        <td><input type=text size=15 id=ts value="2021-01-29 00:00:00" placeholder="AAAA-MM-DD HH:MM:SS"></td>
      </tr>
    </table>
    <table>
      <tr>
        <td>Précision : </td>
        <td><input type=text id=interval value=3600 size=4></td>
        <td> secondes</td>
      </tr>
    </table>
    <br>
    <div id="heating"></div>
    <div id="chart"></div>
    <div id="out"></div>
  </div>
</div>

<script>

//var root = "http://127.0.0.1/bios";
var root = "http://allierhab.ddns.net/bios";

// tailles en pixel
var largeur = 600;
var hauteur = 160;
// all the margins
var margin = ({top: 20, right: 50, bottom: 20, left: 50})

outdoorColors = {"froze": "#00006F", "cold": "#6a70fe", "heat": "#defe85"}
indoorColors = {"cold": "#377eb8", "confort": "#4daf4a", "heat": "#e49f1a"}
//feba01

function humanTime2ts(){
  /*
  convertit le temps indiqué dans la div ts en unix timestamp
  */
  let start = $("#ts").val();
  let human = new Date(start);
  // donne le même résultat que Date.parse(start)/1000
  let ts = human.getTime()/1000;
  return ts
}

function wrap(text, width) {
  /*
  Affiche un texte sur plusieurs lignes dès lors qu'il dépasse une certaine largeur
  cf mike Bockstock
  cf https://bl.ocks.org/mbostock/7555321
  and https://bl.ocks.org/guypursey/f47d8cd11a8ff24854305505dbbd8c07
  More to read on : https://github.com/d3/d3/issues/1642
  */
  text.each(function() {
    var text = d3.select(this),
        words = text.text().split(/\s+/).reverse(),
        word,
        line = [],
        lineNumber = 0,
        lineHeight = 1.1, // ems
        y = text.attr("y"),
        dy = parseFloat(text.attr("dy")),
        tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
    //console.log(words);
    while (word = words.pop()) {
      line.push(word);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > width) {
        line.pop();
        tspan.text(line.join(" "));
        line = [word];
        tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
      }
    }
  });
}

function createCircuitUrl(root){
  /*
  construit l'url pour requêter les statistiques sur un circuit
  */
  let Tmin = $("#Tmin").val();
  let Tmax = $("#Tmax").val();
  let interval = $("#interval").val();
  let circuit = $("#circuit").val();
  let ts = humanTime2ts();
  //console.log(circuit);
  //console.log(ts);
  let circuiturl = root+"/network/"+circuit+'/'+ts+"?interval="+interval+"&Tmin="+Tmin+"&Tmax="+Tmax;
  return(circuiturl);
}

function raw(url){
  /*
  permet de visualiser les données brutes
  */
  $.ajax({
    url: url,
    dataType: "json",
    async: true,
    success(data) {
      if (data["Tint"]) {
        // min et max
        let min = d3.min(data["Tint"]);
        let max = d3.max(data["Tint"]);
        let confortmin = $("#Tmin").val();
        let confortmax = $("#Tmax").val();
        let u = new URL(url);
        let ts = u.pathname.split("/")[3] * 1000;
        // jour de la semaine avec une date longue
        let options = {weekday: "long", year: "numeric", month: "long", day: "numeric"};
        let human = new Date(ts).toLocaleDateString('fr-FR', options);
        let titre = "Données brutes pour la semaine du "+human;

        // on efface le contenu de la div et on recrée le svg responsif
        d3.select("#chart").selectAll("*").remove();
        const rawchart = d3
          .select("#chart")
          .append("svg")
            .attr("preserveAspectRatio", "xMinYMin meet")
            .attr("viewBox", [0, 0, largeur, hauteur])
            .on("click",function(d) {
              d3.select("#chart").selectAll("*").remove();
            });

        //titre
        addTitle(rawchart, titre)

        // échelles
        let nbh = data["Tint"].length;
        var x = d3.scaleLinear()
          .domain([0, nbh - 1])
          .range([margin.left, largeur - margin.right]);
        var y = d3.scaleLinear()
          .domain([ min, max ])
          .range([hauteur - margin.bottom, margin.top]);

        // axe des abscisses
        var x_axis = d3.axisBottom().scale(x);
        var xAxisYtranslate = hauteur - margin.bottom;
        rawchart.append("g")
          .attr("transform", "translate(0," + xAxisYtranslate + ")")
          .call(x_axis);

        //axes des ordonnées
        var y_axis = d3.axisLeft().scale(y);
        rawchart.append("g")
          .attr("transform", "translate(" + margin.left + ", 0)")
          .call(y_axis);

        const d = [];
        for (let i = 0; i < nbh; ++i) {
          element = {};
          element.x = x(i);
          element.Tint = y(data["Tint"][i]);
          element.agenda = y(20*data["agenda"][i]);
          d.push(element);
        }

        //remplissage de la zone d'occupation par une couleur
        var area = d3.area()
          .x(d => d.x)
          .y0(hauteur-margin.bottom)
          .y1(d => d.agenda);

        //création d'un masque
        rawchart.append("clipPath")
          .attr("id", "cliprange")
          .append("rect")
            .attr("x", margin.left)
            .attr("y", margin.top)
            .attr("width", largeur - margin.left - margin.right)
            .attr("height", hauteur - margin.top - margin.bottom);

        rawchart.append("path")
          .datum(d)
          .style("fill", "orange")
          .style("opacity", 0.2)
          .attr("clip-path", "url(#cliprange)")
          .attr("d", area);

        // courbe des températures intérieures
        let lineTint = d3.line()
          .x(d => d.x)
          .y(d => d.Tint);

        // gradient de couleur sur y
        rawchart.append("linearGradient")
          .attr("id", "line-gradient")
          .attr("gradientUnits", "userSpaceOnUse")
          .attr("x1", 0)
          .attr("y1", y(confortmin))
          .attr("x2", 0)
          .attr("y2", y(confortmax))
          .selectAll("stop")
              .data([
                {offset: "0%", color: "blue"},
                {offset: "0%", color: "green"},
                {offset: "100%", color: "green"},
                {offset: "150%", color: "red"}
              ])
          .enter().append("stop")
              .attr("offset", function(d) { return d.offset; })
              .attr("stop-color", function(d) { return d.color; });

        rawchart.append("path")
          .datum(d)
          //.attr("clip-path", "uriteml(#cliprange)")
          .attr("stroke", "url(#line-gradient)")
          .attr("d", lineTint);

      }
    }
  });
}

function addTitle(obj, titre) {
  /*
  ajoute un titre à un graphique d3js
  */
  obj.append("text")
    .attr("x", (largeur / 2))
    .attr("y", margin.top / 2)
    .attr("text-anchor", "middle")
    .style("color", "black")
    .style("font-size", "12px")
    .text(titre);
}

function addLegend(obj, colvalues, labels) {
  /*
  ajoute une légende à un graphique d3js
  */
  let legend = obj.append('g')
    .attr('transform', 'translate(0, 20)');
  legendCellSize = 10;
  legend.selectAll()
    .data(colvalues)
    .enter().append('rect')
      .attr('height', legendCellSize+'px')
      .attr('width', legendCellSize+'px')
      .attr('y', (d,i) => i * legendCellSize)
      .style("fill", d => d);
  legend.selectAll()
    .data(labels)
    .enter().append('text')
      .attr("transform", (d,i) => "translate(" + (legendCellSize+2) + ", " + (i * legendCellSize) + ")")
      .attr("dy", legendCellSize / 1.4) // Pour centrer le texte par rapport aux carrés
      .style("font-size", "7px")
      .style("color", "black")
      .text(d => d);
}

function heatmap(url, divName, colors, titre = "", ylabel = "% temps", click = false) {
  /*
  construit une carte de chaleur sous la forme d'histogramme en barre
  */
  let u = new URL(url);
  let params = new URLSearchParams(u.search);
  let min = parseInt(params.get("Tmin"));
  let max = parseInt(params.get("Tmax"));
  let labels = [];
  labels.push("< "+min+"°C");
  labels.push(min+" à "+max+"°C");
  labels.push("> "+max+"°C");

  // on extrait les clés/dénominations de couleurs et les valeurs hexa correspondantes
  let colkeys = Object.keys(colors);
  let colvalues = Object.values(colors);
  // on requête l'API
  $.ajax({
    url: url,
    dataType: "json",
    async: true,
    success(data) {
      if (data["stats"]){
        // Si on a des stats, on efface le contenu de la div et on recrée le svg responsif
        d3.select(divName).selectAll("*").remove();
        let svg = d3.select(divName).append("svg")
          .attr("preserveAspectRatio", "xMinYMin meet")
          .attr("viewBox", [0, 0, largeur, hauteur]);
        addTitle(svg, titre);

        let xx = margin.right/2;
        let yy = margin.top + 2*hauteur / 3;
        let a = ylabel.split("\n");
        a.forEach((item, i) => {
          svg.append("text")
            .style("font-size", "10px")
            .text(item)
            .attr("transform", "translate("+(xx+i*10)+","+yy+") rotate(-90)")
        });

        addLegend(svg, colvalues, labels);

        // axe des x pour se repérer sur semaines
        let weeks = d3.map(data["stats"], function(d){return(d.humanTimeShort)});
        let x = d3.scaleBand()
          .domain(weeks)
          .range([margin.left, largeur - margin.right])
          .padding([0.2]);
        svg.append("g")
          .attr("id", "text-legend")
          .attr("transform", "translate(0," + (hauteur - margin.bottom) + ")")
          .style("font-size", "6px")
          .call(d3.axisBottom(x).tickSizeOuter(0))
        .selectAll(".tick text")
          .call(wrap, x.bandwidth());

        // échelle des y - on n'affiche pas l'axe
        let y = d3.scaleLinear()
          .domain([0, 100])
          .range([ hauteur - margin.bottom,  margin.top ]);
        // palette de couleurs
        let colormap = d3.scaleOrdinal()
          .domain(colkeys)
          .range(colvalues)
        // on stacke nos données
        let stackGen = d3.stack()
          .keys(colkeys);
        let stackedSeries = stackGen(data["stats"]);
        // stackedSeries contient 3 ensembles de données, un pour chaque "clé" de chaleur
        // on peut afficher la clé de l'ensemble 0
        // console.log(stackedSeries[0].key);
        // chaque ensemble de données est composé de tableaux de taille 2
        // chaque tableau de taille 2 est associé à une clé data, qui contient toutes les données originelles
        // construit l'histogramme
        svg.append("g")
          .selectAll("g")
          // première boucle - on parcourt les données stackées
          // les 3 plages de chaleur (cold, confort et heat) sont les clés
          .data(stackedSeries)
          .enter().append("g")
            .attr("fill", function(d) { return colormap(d.key); })
            .selectAll("rect")
            // seconde boucle pour construire les rectangles
            .data(function(d) { return d; })
            .enter().append("rect")
              .attr("x", function(d) { return x(d.data.humanTimeShort); })
              .attr("y", function(d) { return y(d[1]); })
              .attr("height", function(d) { return y(d[0]) - y(d[1]); })
              .attr("width",x.bandwidth());
        if (click === true){
          // on récupère le nom du circuit en parsant l'url
          let circuit = u.pathname.split("/")[3];
          // on pourrait aussi faire $("#circuit option:selected").val();
          // on récupère la valeur de l'intervalle de discrétisation
          let interval = $("#interval").val();
          svg.selectAll("g").selectAll("g")
            .data(stackedSeries)
            .on("click",function(d) {
              let ts = d.srcElement.__data__.data.ts;
              let rawurl = root + "/" + circuit + "/" + ts + "?interval=" + interval;
              //console.log(rawurl);
              raw(rawurl);
            })
          }
        }
      }
    });
  }

function indoorHeatmap(url) {
  let titre = "température intérieure / confort thermique";
  heatmap(url, "#heating", indoorColors, titre = titre, ylabel = "% temps\nd'occupation", click = true);
}

function outdoorHeatmap() {
  let ts = humanTime2ts();
  let interval = $("#interval").val();
  let titre = "température extérieure";
  let exturl = root+"/text/"+ts+"?interval="+interval+"&Tmin=0&Tmax=10";
  heatmap(exturl, "#out", outdoorColors, titre = titre);
}

function buildSelectAndInit(root){
  //affiche le menu déroulant permettant le choix des circuits
  //initialise la carte de chaleur avec les paramètres initiaux
  $.ajax({
    url: root+"/network",
    dataType: "json",
    async: true,
    success(data) {
      //création du tableau pour héberger le contenu du select
      let options=[];
      let allcircuits=Object.getOwnPropertyNames(data);
      allcircuits.forEach(function(circuit, indice){
        //console.log(circuit);
        //console.log(data[circuit].Tint);
        var tag ="";
        if (indice === 0) {
          tag = " selected";
        }
        options.push("<option value="+circuit+tag+">Zone "+circuit+"</option>");
      });
      $("#circuit").html(options);
      let circuiturl = createCircuitUrl(root);
      indoorHeatmap(circuiturl);
      outdoorHeatmap();
    }
  });
}

buildSelectAndInit(root);


$("#filter").on("change", function(){
  let circuiturl = createCircuitUrl(root);
  indoorHeatmap(circuiturl, root);
  outdoorHeatmap();
});

</script>
</body>
