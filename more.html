<!DOCTYPE html>
<meta charset="utf-8">
<style>

body { font: 10px Arial;}

path {
    stroke-width: 1;
    fill: none;
}

.axis path,
.axis line {
    fill: none;
    stroke: grey;
    stroke-width: 1;
    shape-rendering: crispEdges;
}

.axisRed text{
  fill: red;
}

div.tooltip {
    position: absolute;
    text-align: center;
	color: white;
	padding: 2px;
	font: 12px sans-serif;
	background: grey;
	border: 0px;
	border-radius: 8px;
	pointer-events: none;
	}

</style>
<body>
<!--<script src="https://d3js.org/d3.v4.min.js"></script>-->
<script src="lib/d3.v6.min.js"></script>
<script src="lib/jquery-3.5.1.min.js"></script>
<link rel="stylesheet" href="lib/bootstrap-4.5.3-dist/css/bootstrap.min.css">
<script src="lib/bootstrap-4.5.3-dist/js/bootstrap.bundle.min.js"></script>
<div class="container-fluid">
<div class="row-sm" id="filter">
  <table class="table">
    <tr><td colspan=2><img src=img/logo.svg class="img-fluid"></td></tr>
    <tr><td colspan=2>
      <dd>
        Chez OBM, on cherche en permanence à produire des données signifiantes pour nos clients.
        Nos automates ne se contentent pas de recueillir et stocker les données brutes.
        Ils embarquent une API produisant de l'information compréhensible par les humains.
      </dd>
      <dd>
        La visualisation ci dessous représente la répartition du temps d'occupation des locaux suivant 3 catégories de confort thermique.
        On peut parler de carte de chaleur.
      </dd>
    </td></tr>
    <tr>
      <td>Circuit : <select id=circuit></select></td>
      <td>Pas de temps : <input type=text id=interval value=3600 size=4> secondes</td>
    </tr>
    <tr><td colspan=2>
      Date : <input type=text id=ts value="2021-01-29 00:00:00" placeholder="AAAA-MM-DD HH:MM:SS">
      <span id=humantime></span>
    </td></tr>
    <tr><td colspan=2>
      <dd>
        Vert = zone de confort - température intérieure entre
        <input type=text id=Tmin value=19 size=2>°C et <input type=text id=Tmax value=21 size=2>°C
      </dd>
      <dd>Bleu = zone froide - température intérieure inférieure à <span id=cold>18</span>°C</dd>
      <dd>Orange = zone chaude - température intérieure supérieure à <span id=heat>21</span>°C</dd>
    </td></tr>
    <tr><td colspan=2><div id="heating"></div></td></tr>
    <tr><td colspan=2><div id="chart"></div></td></tr>
  </table>
</div>
</div>

<script>

//var url = "http://127.0.0.1/bios";
var url = "http://allierhab.ddns.net/bios";

// tailles en pixel
var largeur = 600;
var hauteur = 160;
// all the margins
var margin = ({top: 10, right: 50, bottom: 20, left: 50})
// the y scales
var min = 17;
var max = 21;

function wrap(text, width) {
/*
Affiche un texte sur plusieurs lignes dès lors qu'il dépasse une certaine largeur
cf mike Bockstock
cf https://bl.ocks.org/mbostock/7555321
and https://bl.ocks.org/guypursey/f47d8cd11a8ff24854305505dbbd8c07
More to read on : https://github.com/d3/d3/issues/1642
*/
    text.each(function() {
        var text = d3.select(this),
            words = text.text().split(/\s+/).reverse(),
            word,
            line = [],
            lineNumber = 0,
            lineHeight = 1.1, // ems
            y = text.attr("y"),
            dy = parseFloat(text.attr("dy")),
            tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
        //console.log(words);
        while (word = words.pop()) {
            line.push(word);
            tspan.text(line.join(" "));
            if (tspan.node().getComputedTextLength() > width) {
                line.pop();
                tspan.text(line.join(" "));
                line = [word];
                tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
            }
        }
    });
}

function createCircuitUrl(url){
  /*
  construit l'url pour requêter les statistiques sur un circuit
  */
  let Tmin = $("#Tmin").val();
  let Tmax = $("#Tmax").val();
  let interval = $("#interval").val();
  let circuit = $("#circuit").val();
  let start = $("#ts").val();
  let human = new Date(start);
  // donne le même résultat que Date.parse(start)/1000
  let ts = human.getTime()/1000;
  //console.log(circuit);
  //console.log(ts);
  $("#cold").html(Tmin);
  $("#heat").html(Tmax);
  $("#humantime").html(human);
  let apiurl = url+"/network/"+circuit+'/'+ts+"?interval="+interval+"&Tmin="+Tmin+"&Tmax="+Tmax;
  return(apiurl);
}

function raw(apiurl){
  /*
  permet de visualiser les données brutes
  */
  $.ajax({
    url: apiurl,
    dataType: "json",
    async: true,
    success(data) {
      if (data["Tint"]) {
        // min et max
        let min = d3.min(data["Tint"]);
        let max = d3.max(data["Tint"]);
        let confortmin = $("#Tmin").val();
        let confortmax = $("#Tmax").val();
        // on efface le contenu de la div et on recrée le svg responsif
        d3.select("#chart").selectAll("*").remove();
        const rawchart = d3
          .select("#chart")
          .append("svg")
            .attr("preserveAspectRatio", "xMinYMin meet")
            .attr("viewBox", [0, 0, largeur, hauteur])

        // échelles
        let nbh = data["Tint"].length;
        var x = d3.scaleLinear()
          .domain([0, nbh - 1])
          .range([margin.left, largeur - margin.right]);
        var y = d3.scaleLinear()
          .domain([ min, max ])
          .range([hauteur - margin.bottom, margin.top]);

        // axe des abscisses
        var x_axis = d3.axisBottom().scale(x);
        var xAxisYtranslate = hauteur - margin.bottom;
        rawchart.append("g")
          .attr("transform", "translate(0," + xAxisYtranslate + ")")
          .call(x_axis);

        //axes des ordonnées
        var y_axis = d3.axisLeft().scale(y);
        rawchart.append("g")
          .attr("transform", "translate(" + margin.left + ", 0)")
          .call(y_axis);

        const d = [];
        for (let i = 0; i < nbh; ++i) {
          element = {};
          element.x = x(i);
          element.Tint = y(data["Tint"][i]);
          element.agenda = y(20*data["agenda"][i]);
          d.push(element);
        }

        //remplissage de la zone d'occupation par une couleur
        var area = d3.area()
          .x(d => d.x)
          .y0(hauteur-margin.bottom)
          .y1(d => d.agenda);

        //création d'un masque
        rawchart.append("clipPath")
          .attr("id", "cliprange")
          .append("rect")
            .attr("x", margin.left)
            .attr("y", margin.top)
            .attr("width", largeur - margin.left - margin.right)
            .attr("height", hauteur - margin.top - margin.bottom);

        rawchart.append("path")
          .datum(d)
          .style("fill", "orange")
          .style("opacity", 0.5)
          .attr("clip-path", "url(#cliprange)")
          .attr("d", area);

        // courbe des températures intérieures
        let lineTint = d3.line()
          .x(d => d.x)
          .y(d => d.Tint);

        // gradient de couleur sur y
        rawchart.append("linearGradient")
          .attr("id", "line-gradient")
          .attr("gradientUnits", "userSpaceOnUse")
          .attr("x1", 0)
          .attr("y1", y(confortmin))
          .attr("x2", 0)
          .attr("y2", y(confortmax))
          .selectAll("stop")
              .data([
                {offset: "0%", color: "blue"},
                {offset: "0%", color: "green"},
                {offset: "100%", color: "green"},
                {offset: "150%", color: "red"}
              ])
          .enter().append("stop")
              .attr("offset", function(d) { return d.offset; })
              .attr("stop-color", function(d) { return d.color; });

        rawchart.append("path")
          .datum(d)
          //.attr("clip-path", "uriteml(#cliprange)")
          .attr("stroke", "url(#line-gradient)")
          .attr("d", lineTint);

      }
    }
  });
}

function indoorHeatmap(apiurl) {
  /*
  construit la carte de chaleur des températures intérieures pour le circuit
  sous forme d'histogramme en barre
  */
  // on commence par effacer la div
  $("#heating").html("");
  const u = new URL(apiurl);
  // on récupère le nom du circuit en parsant l'url
  const circuit = u.pathname.split("/")[3];
  // on pourrait aussi faire $("#circuit option:selected").val();
  // on récupère la valeur de l'intervalle de discrétisation
  const interval = $("#interval").val();

  // on requête l'API
  $.ajax({
    url: apiurl,
    dataType: "json",
    async: true,
    success(data) {
      if (data["stats"]){
        // Si on a des stats, on initialise un svg responsif
        const heating = d3
          .select("#heating").append("svg")
              .attr("preserveAspectRatio", "xMinYMin meet")
              .attr("viewBox", [0, 0, largeur, hauteur])
        let weeks = d3.map(data["stats"], function(d){return(d.humanTimeShort)});
        //console.log(weeks);
        // axe des x pour se repérer sur semaines
        let x = d3.scaleBand()
           .domain(weeks)
           .range([margin.left, largeur - margin.right])
           .padding([0.2]);
        heating.append("g")
           .attr("id", "text-legend")
           .attr("transform", "translate(0," + (hauteur - margin.bottom) + ")")
           .style("font-size", "6px")
           .call(d3.axisBottom(x).tickSizeOuter(0))
        .selectAll(".tick text")
           .call(wrap, x.bandwidth());

        // échelle des y - on n'affiche pas l'axe
        let y = d3.scaleLinear()
           .domain([0, 100])
           .range([ hauteur - margin.bottom,  margin.top ]);
        // palette de couleurs
        let color = d3.scaleOrdinal()
           .domain(["cold","confort","heat"])
           .range(['#377eb8','#4daf4a','#e49f1a'])
        // on stacke nos données
        let stackGen = d3.stack()
           .keys(["cold","confort","heat"]);
        let stackedSeries = stackGen(data["stats"]);
        // stackedSeries contient 3 ensembles de données, un pour chaque "clé" de chaleur
        // on peut afficher la clé de l'ensemble 0
        // console.log(stackedSeries[0].key);
        // chaque ensemble de données est composé de tableaux de taille 2
        // chaque tableau de taille 2 est associé à une clé data, qui contient toutes les données originelles
        // construit l'histogramme
        heating.append("g")
           .selectAll("g")
           // première boucle - on parcourt les données stackées
           // les 3 plages de chaleur (cold, confort et heat) sont les clés
           .data(stackedSeries)
           .enter().append("g")
               .attr("fill", function(d) {
                 //console.log(d);
                 return color(d.key); })
               .selectAll("rect")
               // seconde boucle pour construire les rectangles
               .data(function(d) { return d; })
               .enter().append("rect")
                   .attr("x", function(d) {
                     //console.log(d);
                     return x(d.data.humanTimeShort); })
                   .attr("y", function(d) { return y(d[1]); })
                   .attr("height", function(d) { return y(d[0]) - y(d[1]); })
                   .attr("width",x.bandwidth())
                   .on("click",function(d) {
                     let ts = d.srcElement.__data__.data.ts;
                     let rawurl = url + "/" + circuit + "/" + ts + "?interval=" + interval;
                     console.log(rawurl);
                     raw(rawurl);
                   });

      }
    }
  });
}

function buildSelectAndInit(){
  //affiche le menu déroulant permettant le choix des circuits
  //initialise la carte de chaleur avec les paramètres initiaux
  $.ajax({
    url: url+"/network",
    dataType: "json",
    async: true,
    success(data) {
      //création du tableau pour héberger le contenu du select
      let options=[];
      let allcircuits=Object.getOwnPropertyNames(data);
      allcircuits.forEach(function(circuit, indice){
        //console.log(circuit);
        //console.log(data[circuit].Tint);
        var tag ="";
        if (indice === 0) {
          tag = " selected";
        }
        options.push("<option value="+circuit+tag+">"+circuit+"</option>");
      });
      $("#circuit").html(options);
      let apiurl = createCircuitUrl(url);
      indoorHeatmap(apiurl);
    }
  });
}

buildSelectAndInit();

$("#filter").on("change", function(){
  let apiurl = createCircuitUrl(url);
  indoorHeatmap(apiurl);
});

</script>
</body>
